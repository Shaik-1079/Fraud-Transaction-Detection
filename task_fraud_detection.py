# -*- coding: utf-8 -*-
"""Task_Fraud_Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cQXoQTHWNeTc_3ldFai7UaHsuRU3HpIA
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd                                                                
import numpy as np                                              
import matplotlib.pyplot as plt                                                                       
import seaborn as sns                                                                     
from sklearn.model_selection import train_test_split

from sklearn.model_selection import cross_val_score
import warnings
warnings.filterwarnings('ignore')
# %matplotlib inline

from google.colab import drive
drive.mount('/content/drive')
path="/content/drive/MyDrive/Fraud.csv"
data= pd.read_csv(path)

data.info

Categorical_features=[feature for feature in data.columns if data[feature].dtypes == 'object']
Numerical_features=[feature for feature in data.columns if data[feature].dtypes != 'object']
Continous_features=[]

for feature in Categorical_features:
    print(f'Number of unique values in column {feature} is {data[feature].nunique()}')
    if data[feature].nunique()>15:
        Continous_features.append(feature)

plt.figure(figsize=(5,5),dpi=150)
sns.heatmap(data.isna(),yticklabels=False,cbar=False,cmap='magma')

"""INFERENCE: THERE ARE NO NULL OR NA VALUES IN THE DATASET (MISSSING VALUES)

CORRELATION
"""

plt.figure(figsize=(8,8))
sns.heatmap(data.corr(),annot=True,cmap='rainbow')

"""INFERENCE: 

1.  OldbalanceOrig & newbalanaceOrig are strongly correlated
2.  OldbalanceDest & newBalanceDest are also correlated


with some other results from the heatmap


"""

var = data.groupby('type').amount.sum()
fig = plt.figure()
ax1 = fig.add_subplot(1,1,1)
var.plot(kind='bar')
ax1.set_xlabel('Type of Transaction')
ax1.set_ylabel('Amount');

data.loc[data.isFraud == 1].type.unique()

"""This Shows that Frauds happen in these two TYPES of Transactions : TRANSFER, CASH_OUT.

"""

#Diving Cases into Fraud and Non Fraud
fraud = data.loc[data.isFraud == 1]
nonfraud = data.loc[data.isFraud == 0]

fig = plt.figure()
axes = fig.add_subplot(1,1,1)
axes.scatter(nonfraud['amount'],nonfraud['isFlaggedFraud'],c='y')
axes.scatter(fraud['amount'],fraud['isFlaggedFraud'],c='r')
plt.legend(loc='upper right',labels=['Not Flagged','Flagged'])
plt.show()

"""The Above Plot Shows Fraud Transactions Which have been Flagged or Not. This shows a need for a system That is fast in Flagging these kinds of transactions. The transactions taggind system needs to modified, tested and implemented to flag these transactions."""

plt.hist(nonfraud['step'], bins=100)

plt.hist(fraud['step'], bins=100)

"""The Above Histogram plot shows that : Non fraud transcations dont run for long steps and fraud transaactions runs for more time But Some fraud transactions can run for short amount of time. Large Steps Transactions need to Cancelled based on pther parameters to prevent Fraudulant Transactions"""

data.drop(['nameOrig','nameDest','isFlaggedFraud'],axis=1,inplace=True)

data['type'].value_counts()

#1 Hot Encoding FOR TYPE DATA
one_data = pd.get_dummies(data, columns = ['type'])

one_data.dtypes

"""Other Encoding Functions like Label Encoder can also be used to encode the categorical values in our case that is ['Type']"""

Z=one_data.drop(['isFraud'],axis=1)
w=one_data.isFraud

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(Z, w, test_size = 0.2, random_state = 1) 
#train test split (the sklearn.model_selection import train_test_split is only capable of splitting into two not into three)

X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.25, random_state=1) #Validataion Split

"""Decision Tree

"""

from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix

def prediction(X_test, clf_object):
y_pred = clf_object.predict(X_test)
print("Predicted values:")
print(y_pred)
return y_pred

def train_using_entropy(X_train, X_test, y_train):
clf_entropy = DecisionTreeClassifier(criterion = "entropy", random_state = 100, max_depth = 3, min_samples_leaf = 5)
clf_entropy.fit(X_train, y_train)
return clf_entropy

def cal_accuracy(y_test, y_pred):
print("Confusion Matrix: ", confusion_matrix(y_test, y_pred))
print ("Accuracy : ", accuracy_score(y_test,y_pred)*100)
print("Report : ", classification_report(y_test, y_pred))

def main():
clf_entropy = train_using_entropy(X_train, X_test, y_train)
print("Results Using Entropy:")
y_pred_entropy = prediction(X_test, clf_entropy)
cal_accuracy(y_test, y_pred_entropy)
if __name__=="__main__":
main()

"""Random Forest"""

from sklearn.ensemble import RandomForestClassifier
clf = RandomForestClassifier(n_estimators = 100) 
clf.fit(X_train, y_train)
y_pred = clf.predict(X_test)
from sklearn import metrics 
print()
print("ACCURACY OF THE MODEL: ", metrics.accuracy_score(y_test, y_pred))

"""Similarly the isFlaggedFraud can be predicted in same manner. Here We are getting good results due to 1 Hot Encoding feature to encode the categorical data['Type']

> As we can see the results using Decision Tree and Random Forest 


"""